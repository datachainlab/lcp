syntax = "proto3";
package ibc.lightclients.lcp.v1;

import "gogoproto/gogo.proto";
import "ibc/core/client/v1/client.proto";

option go_package = "github.com/datachainlab/lcp/go/light-clients/lcp/types";
option (gogoproto.goproto_getters_all) = false;

// A message containing information required to update the client.
message UpdateClientMessage {
  // A proxy message generated by the LCP node running on the target platform
  bytes proxy_message = 1;
  // Signatures of the proxy message by the LCP node
  repeated bytes signatures = 2;
}

// A message to verify IAS report and signature for the enclave key registration
message RegisterEnclaveKeyMessage {
  // IAS report
  bytes report = 1;
  // A signature of the IAS report by the IAS signing key
  bytes signature = 2;
  // A certificate of the IAS signing key
  bytes signing_cert = 3;
  // An operator's signature of the EIP-712 message `RegisterEnclaveKey`
  bytes operator_signature = 4;
}

// A message to verify zkDCAP's output and proof for the enclave key registration
message ZKDCAPRegisterEnclaveKeyMessage {
  // A type of zkVM generated the `quote_verification_output` and `proof`
  uint32 zkvm_type = 1;
  // An output of the zkDCAP program that verifies the quote
  bytes quote_verification_output = 2;
  // A proof of the zkVM generated the `quote_verification_output`
  bytes proof = 3;
  // An operator's signature of the EIP-712 message `ZKDCAPRegisterEnclaveKey`
  bytes operator_signature = 4;
}

message UpdateOperatorsMessage {
  // A nonce for this operators update
  uint64 nonce = 1;
  // A list of new operators
  repeated bytes new_operators = 2;
  // A numerator of the threshold of signatures required for new operators
  uint64 new_operators_threshold_numerator = 3;
  // A denominator of the threshold of signatures required for new operators
  uint64 new_operators_threshold_denominator = 4;
  // Signatures of the EIP-712 message `UpdateOperators` by the current operators
  repeated bytes signatures = 5;
}

message ClientState {
  // This value strictly identifies the allowed enclave.
  bytes mrenclave = 1;

  // The `key_expiration` is used to determine the validity period of the EK.
  //
  // The logic for calculating EK validity periods slightly differs between IAS and DCAP:
  //
  // IAS:
  // - This value must be greater than 0.
  // - The EK validity ends at `ias_report.timestamp + key_expiration`.
  //
  // DCAP:
  // - If the value is 0, the EK validity ends at `output.validity.not_after`.
  // - If the value is greater than 0, the EK validity ends at:
  //   min(`qv_output.validity.not_before` + key_expiration, `output.validity.not_after`)
  //
  // Considerations:
  // - Operators should fetch the latest collateral from Intel Provisioning Certification Service (PCS) to ensure the EK validity starts close to the current time.
  // - When the EK expires and the TCB evaluation data number has been updated, operators might not be immediately ready
  //   to operate with the newly accepted TCB status, resulting in availability risks.
  //   To mitigate this risk, operators should set an appropriate `tcb_evaluation_data_number_update_grace_period`. 
  uint64 key_expiration = 2;

  // Indicates whether the client is frozen.
  bool frozen = 3;

  // The height of the latest consensus state that the client has tracked
  ibc.core.client.v1.Height latest_height = 4 [(gogoproto.nullable) = false];

  // Determines which SGX enclave quote statuses are acceptable.
  //
  // Operators must configure this carefully based on their operational
  // security posture and environment-specific considerations.
  //
  // e.g. IAS: SW_HARDENING_NEEDED, CONFIGURATION_AND_SW_HARDENING_NEEDED
  //      DCAP: SWHardeningNeeded, ConfigurationAndSWHardeningNeeded
  repeated string allowed_quote_statuses = 5;

  // Specifies Security Advisory IDs that operators explicitly allow.
  //
  // Operators must carefully consider the security implications of allowing specific advisories.
  //
  // e.g. INTEL-SA-00001, INTEL-SA-00002
  repeated string allowed_advisory_ids = 6;

  // A list of LCP operator addresses (ethereum format) associated with this client.
  //
  // If this field is empty, operator signatures are not required, allowing any entity to act as an operator.
  //
  // Operational assumptions:
  // - At least one operator (including entities not listed in the `operators` field) is expected to promptly reference and report the latest TCB evaluation data number.
  //   - If no operator promptly reports the latest TCB number, the client continues accepting attestations based on outdated collateral for up to 12 months.
  // - Not all operators may immediately prepare an SGX environment compatible with the latest TCB level.
  //   - The `tcb_evaluation_data_number_update_grace_period` ensures that all operators have a guaranteed minimum period to update their SGX environments, maintaining overall availability.
  repeated bytes operators = 7;

  // The current nonce used in operator updates.
  uint64 operators_nonce = 8;

  // The numerator of the signature threshold for operator updates.
  uint64 operators_threshold_numerator = 9;

  // The denominator of the signature threshold for operator updates.
  uint64 operators_threshold_denominator = 10;

  // The current TCB evaluation data number
  //
  // The client only accepts the zkDCAP output generated using collateral with a TCB evaluation data number equal to or greater than this number.
  uint32 current_tcb_evaluation_data_number = 11;

  // The grace period (in seconds) for operators to update their SGX environments to support a newly observed TCB evaluation data number.
  //
  // Notes:
  // - A shorter grace period could increase availability risk if operators are not given sufficient time
  //   to prepare the new SGX environment compatible with the updated TCB level.
  // - Conversely, a longer grace period could delay the adoption of the latest TCB level, potentially increasing security risks.
  // - Operators must carefully consider their operational preparation needs and security posture when configuring this value.
  //
  // When a new TCB evaluation data number greater than the current number is observed:
  //
  // - If the grace period is zero:
  //   - The current number is updated immediately.
  //
  // - If the grace period is non-zero:
  //   - The new number is reserved as `next_tcb_evaluation_data_number`.
  //   - `next_tcb_evaluation_data_number_update_time` is set to current timestamp plus the grace period.
  //
  // Edge cases:
  //
  //   - Edge case 1 (current < next < newly observed number):
  //     - Immediate activation of reserved next number, bypassing the remaining grace period.
  //     - Newly observed number is reserved as the next number.
  //
  //   - Edge case 2 (current < newly observed number < next):
  //     - Immediate activation of newly observed number, preserving the reserved next number.
  //
  // These edge cases can occur due to excessively long grace periods or frequent TCB Recovery Events occurring within shorter intervals than the typical 6-month update frequency.
  // Note that we assume operators can maintain an appropriate TCB status based on previous TCB collateral. Therefore, we expect that immediate updates in these edge cases do not cause operational issues.
  // Additionally, with a well-configured grace period aligned with typical TCB update intervals, the client will never skip the configured grace period for any TCB number update.
  uint32 tcb_evaluation_data_number_update_grace_period = 12;

  // Next TCB evaluation data number scheduled to be updated
  //
  // Notes:
  // - Must be zero if and only if `next_tcb_evaluation_data_number_update_time` is zero.
  // - When `tcb_evaluation_data_number_update_grace_period` is zero, this field must always be zero.
  // - If this is non-zero, this number must be always greater than the `current_tcb_evaluation_data_number`.
  uint32 next_tcb_evaluation_data_number = 13;

  // Scheduled update time of the next TCB evaluation data number (UNIX time seconds)
  //
  // Notes:
  // - Must be zero if and only if `next_tcb_evaluation_data_number` is zero.
  // - When `tcb_evaluation_data_number_update_grace_period` is zero, this field must always be zero.
  uint64 next_tcb_evaluation_data_number_update_time = 14;

  // Contains verifier-specific information for zkDCAP proofs.
  //
  // Data format:
  // - First byte (0): zkVM type identifier.
  // - Remaining bytes (1–N): zkVM-specific data.
  //
  // Currently, only RISC Zero zkVM (type=1) is supported, with the following format:
  //
  // | Byte(s) | Description                 |
  // |---------|-----------------------------|
  // | 0       | zkVM type (fixed as 1)      |
  // | 1–31    | Reserved (set as zero)      |
  // | 32–63   | Image ID                    |
  repeated bytes zkdcap_verifier_infos = 15;
}

message ConsensusState {
  // An identifier that uniquely indicates the ELC state at a specific height
  //
  // Please check the state ID details: <https://docs.lcp.network/protocol/elc#state-id>
  bytes state_id = 1;
  // The timestamp of the target chain's block corresponding to the consensus height,
  // expressed in UNIX time (seconds).
  uint64 timestamp = 2;
}
