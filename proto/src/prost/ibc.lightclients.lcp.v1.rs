#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateClientMessage {
    /// A message generated by the LCP node running on the target platform
    #[prost(bytes = "vec", tag = "1")]
    pub proxy_message: ::prost::alloc::vec::Vec<u8>,
    /// Signatures of the proxy message by the LCP node
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub signatures: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
/// A message to verify IAS report and signature for the enclave key registration
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterEnclaveKeyMessage {
    /// IAS report
    #[prost(bytes = "vec", tag = "1")]
    pub report: ::prost::alloc::vec::Vec<u8>,
    /// A signature of the IAS report by the IAS signing key
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// A certificate of the IAS signing key
    #[prost(bytes = "vec", tag = "3")]
    pub signing_cert: ::prost::alloc::vec::Vec<u8>,
    /// An operator's signature of the EIP-712 message `RegisterEnclaveKey`
    #[prost(bytes = "vec", tag = "4")]
    pub operator_signature: ::prost::alloc::vec::Vec<u8>,
}
/// A message to verify zkDCAP output and proof for the enclave key registration
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZkdcapRegisterEnclaveKeyMessage {
    /// A type of zkVM generated the `quote_verification_output` and `proof`
    #[prost(uint32, tag = "1")]
    pub zkvm_type: u32,
    /// An output of the zkDCAP program that verifies the quote
    #[prost(bytes = "vec", tag = "2")]
    pub quote_verification_output: ::prost::alloc::vec::Vec<u8>,
    /// A proof of the zkVM generated the `quote_verification_output`
    #[prost(bytes = "vec", tag = "3")]
    pub proof: ::prost::alloc::vec::Vec<u8>,
    /// An operator's signature of the EIP-712 message `ZKDCAPRegisterEnclaveKey`
    #[prost(bytes = "vec", tag = "4")]
    pub operator_signature: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateOperatorsMessage {
    /// A nonce for this operators update
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// A list of new operators
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub new_operators: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// A numerator of the threshold of signatures required for new operators
    #[prost(uint64, tag = "3")]
    pub new_operators_threshold_numerator: u64,
    /// A denominator of the threshold of signatures required for new operators
    #[prost(uint64, tag = "4")]
    pub new_operators_threshold_denominator: u64,
    /// Signatures of the EIP-712 message `UpdateOperators` by the current operators
    #[prost(bytes = "vec", repeated, tag = "5")]
    pub signatures: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientState {
    /// The MRENCLAVE of the enclave in running on the target platform
    #[prost(bytes = "vec", tag = "1")]
    pub mrenclave: ::prost::alloc::vec::Vec<u8>,
    /// An enclave key's expiration period from the remote attestation time in seconds
    ///
    /// This is only used for the IAS.
    #[prost(uint64, tag = "2")]
    pub key_expiration: u64,
    /// Whether the client is frozen
    #[prost(bool, tag = "3")]
    pub frozen: bool,
    /// The height of the latest consensus state that the client has tracked
    #[prost(message, optional, tag = "4")]
    pub latest_height: ::core::option::Option<
        super::super::super::core::client::v1::Height,
    >,
    /// The quote statuses of the target enclave that the client allows
    ///
    /// e.g. IAS: SW_HARDENING_NEEDED, CONFIGURATION_AND_SW_HARDENING_NEEDED
    ///       DCAP: SWHardeningNeeded, ConfigurationAndSWHardeningNeeded
    #[prost(string, repeated, tag = "5")]
    pub allowed_quote_statuses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Security Advisory IDs that the client allows
    ///
    /// e.g. INTEL-SA-00001, INTEL-SA-00002
    #[prost(string, repeated, tag = "6")]
    pub allowed_advisory_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// A list of addresses of LCP Operators corresponding to this client.
    ///
    /// Please check LCP operator details: <<https://docs.lcp.network/protocol/lcp-client#lcp-operator>>
    #[prost(bytes = "vec", repeated, tag = "7")]
    pub operators: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// A current nonce for the operators update
    #[prost(uint64, tag = "8")]
    pub operators_nonce: u64,
    /// The numerator of the threshold of the signature number for the operators update
    #[prost(uint64, tag = "9")]
    pub operators_threshold_numerator: u64,
    /// The denominator of the threshold of the signature number for the operators update
    #[prost(uint64, tag = "10")]
    pub operators_threshold_denominator: u64,
    /// The latest TCB evaluation data number
    ///
    /// The client updates the number when receiving TCB evaluation data whose number is greater than the current number.
    #[prost(uint32, tag = "11")]
    pub latest_tcb_evalulation_data_number: u32,
    /// Whether to allow the previous TCB evaluation data number
    ///
    /// If this is true, the client will accept the previous TCB evaluation data number (i.e., `latest_tcb_evalulation_data_number` - 1).
    /// Otherwise, the client will only accept the latest TCB evaluation data number or greater.
    #[prost(bool, tag = "12")]
    pub allow_previous_tcb_evalulation_data_number: bool,
    /// The zkVM verifier information for the zkDCAP
    ///
    /// The format is as follows:
    /// 0: zkVM type
    /// 1-N: arbitrary data for each zkVM type
    ///
    /// zkVM type:
    /// 0: unspecified
    /// 1: risc0
    #[prost(bytes = "vec", repeated, tag = "14")]
    pub zkdcap_verifier_infos: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusState {
    /// An identifier that uniquely indicates the state of the ELC corresponding to a certain height.
    ///
    /// Please check the state ID details: <<https://docs.lcp.network/protocol/elc#state-id>>
    #[prost(bytes = "vec", tag = "1")]
    pub state_id: ::prost::alloc::vec::Vec<u8>,
    /// A timestamp of the target chain's block corresponding to the consensus height
    ///
    /// unix timestamp in seconds
    #[prost(uint64, tag = "2")]
    pub timestamp: u64,
}
