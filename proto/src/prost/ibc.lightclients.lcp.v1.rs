/// A message containing information required to update the client.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateClientMessage {
    /// A proxy message generated by the LCP node running on the target platform
    #[prost(bytes = "vec", tag = "1")]
    pub proxy_message: ::prost::alloc::vec::Vec<u8>,
    /// Signatures of the proxy message by the LCP node
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub signatures: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
/// A message to verify IAS report and signature for the enclave key registration
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterEnclaveKeyMessage {
    /// IAS report
    #[prost(bytes = "vec", tag = "1")]
    pub report: ::prost::alloc::vec::Vec<u8>,
    /// A signature of the IAS report by the IAS signing key
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// A certificate of the IAS signing key
    #[prost(bytes = "vec", tag = "3")]
    pub signing_cert: ::prost::alloc::vec::Vec<u8>,
    /// An operator's signature of the EIP-712 message `RegisterEnclaveKey`
    #[prost(bytes = "vec", tag = "4")]
    pub operator_signature: ::prost::alloc::vec::Vec<u8>,
}
/// A message to verify zkDCAP's output and proof for the enclave key registration
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZkdcapRegisterEnclaveKeyMessage {
    /// A type of zkVM generated the `quote_verification_output` and `proof`
    #[prost(uint32, tag = "1")]
    pub zkvm_type: u32,
    /// An output of the zkDCAP program that verifies the quote
    #[prost(bytes = "vec", tag = "2")]
    pub quote_verification_output: ::prost::alloc::vec::Vec<u8>,
    /// A proof of the zkVM generated the `quote_verification_output`
    #[prost(bytes = "vec", tag = "3")]
    pub proof: ::prost::alloc::vec::Vec<u8>,
    /// An operator's signature of the EIP-712 message `ZKDCAPRegisterEnclaveKey`
    #[prost(bytes = "vec", tag = "4")]
    pub operator_signature: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateOperatorsMessage {
    /// A nonce for this operators update
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    /// A list of new operators
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub new_operators: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// A numerator of the threshold of signatures required for new operators
    #[prost(uint64, tag = "3")]
    pub new_operators_threshold_numerator: u64,
    /// A denominator of the threshold of signatures required for new operators
    #[prost(uint64, tag = "4")]
    pub new_operators_threshold_denominator: u64,
    /// Signatures of the EIP-712 message `UpdateOperators` by the current operators
    #[prost(bytes = "vec", repeated, tag = "5")]
    pub signatures: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientState {
    /// This value strictly identifies the allowed enclave.
    #[prost(bytes = "vec", tag = "1")]
    pub mrenclave: ::prost::alloc::vec::Vec<u8>,
    /// The `key_expiration` is used to determine the validity period of the EK.
    ///
    /// The logic for calculating EK validity periods slightly differs between IAS and DCAP:
    ///
    /// IAS:
    /// - This value must be greater than 0.
    /// - The EK validity ends at `ias_report.timestamp + key_expiration`.
    ///
    /// DCAP:
    /// - If the value is 0, the EK validity ends at `output.validity.not_after`.
    /// - If the value is greater than 0, the EK validity ends at:
    ///    min(`qv_output.validity.not_before` + key_expiration, `output.validity.not_after`)
    ///
    /// Considerations:
    /// - Operators should fetch the latest collateral from Intel Provisioning Certification Service (PCS) to ensure the EK validity starts close to the current time.
    /// - When the EK expires and the TCB evaluation data number has been updated, operators might not be immediately ready
    ///    to operate with the newly accepted TCB status, resulting in availability risks.
    ///    To mitigate this risk, operators should set an appropriate `tcb_evaluation_data_number_update_grace_period`.
    #[prost(uint64, tag = "2")]
    pub key_expiration: u64,
    /// Indicates whether the client is frozen.
    #[prost(bool, tag = "3")]
    pub frozen: bool,
    /// The height of the latest consensus state that the client has tracked
    #[prost(message, optional, tag = "4")]
    pub latest_height: ::core::option::Option<
        super::super::super::core::client::v1::Height,
    >,
    /// Determines which SGX enclave quote statuses are acceptable.
    ///
    /// Operators must configure this carefully based on their operational
    /// security posture and environment-specific considerations.
    ///
    /// e.g. IAS: SW_HARDENING_NEEDED, CONFIGURATION_AND_SW_HARDENING_NEEDED
    ///       DCAP: SWHardeningNeeded, ConfigurationAndSWHardeningNeeded
    #[prost(string, repeated, tag = "5")]
    pub allowed_quote_statuses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Specifies Security Advisory IDs that operators explicitly allow.
    ///
    /// Operators must carefully consider the security implications of allowing specific advisories.
    ///
    /// e.g. INTEL-SA-00001, INTEL-SA-00002
    #[prost(string, repeated, tag = "6")]
    pub allowed_advisory_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// A list of LCP operator addresses (ethereum format) associated with this client.
    ///
    /// If this field is empty, operator signatures are not required, allowing any entity to act as an operator.
    ///
    /// Operational assumptions:
    /// - At least one operator (including entities not listed in the `operators` field) is expected to promptly reference and report the latest TCB evaluation data number.
    ///    - If no operator promptly reports the latest TCB number, the client continues accepting attestations based on outdated collateral for up to 12 months.
    /// - Not all operators may immediately prepare an SGX environment compatible with the latest TCB level.
    ///    - The `tcb_evaluation_data_number_update_grace_period` ensures that all operators have a guaranteed minimum period to update their SGX environments, maintaining overall availability.
    #[prost(bytes = "vec", repeated, tag = "7")]
    pub operators: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// The current nonce used in operator updates.
    #[prost(uint64, tag = "8")]
    pub operators_nonce: u64,
    /// The numerator of the signature threshold for operator updates.
    #[prost(uint64, tag = "9")]
    pub operators_threshold_numerator: u64,
    /// The denominator of the signature threshold for operator updates.
    #[prost(uint64, tag = "10")]
    pub operators_threshold_denominator: u64,
    /// The current TCB evaluation data number
    ///
    /// The client only accepts the zkDCAP output generated using collateral with a TCB evaluation data number equal to or greater than this number.
    #[prost(uint32, tag = "11")]
    pub current_tcb_evaluation_data_number: u32,
    /// The grace period (in seconds) for operators to update their SGX environments to support a newly observed TCB evaluation data number.
    ///
    /// Notes:
    /// - A shorter grace period could increase availability risk if operators are not given sufficient time
    ///    to prepare the new SGX environment compatible with the updated TCB level.
    /// - Conversely, a longer grace period could delay the adoption of the latest TCB level, potentially increasing security risks.
    /// - Operators must carefully consider their operational preparation needs and security posture when configuring this value.
    ///
    /// When a new TCB evaluation data number greater than the current number is observed:
    ///
    /// - If the grace period is zero:
    ///    - The current number is updated immediately.
    ///
    /// - If the grace period is non-zero:
    ///    - The new number is reserved as `next_tcb_evaluation_data_number`.
    ///    - `next_tcb_evaluation_data_number_update_time` is set to current timestamp plus the grace period.
    ///
    /// Edge cases:
    ///
    ///    - Edge case 1 (current < next < newly observed number):
    ///      - Immediate activation of reserved next number, bypassing the remaining grace period.
    ///      - Newly observed number is reserved as the next number.
    ///
    ///    - Edge case 2 (current < newly observed number < next):
    ///      - Immediate activation of newly observed number, preserving the reserved next number.
    ///
    /// These edge cases can occur due to excessively long grace periods or frequent TCB Recovery Events occurring within shorter intervals than the typical 6-month update frequency.
    /// Note that we assume operators can maintain an appropriate TCB status based on previous TCB collateral. Therefore, we expect that immediate updates in these edge cases do not cause operational issues.
    /// Additionally, with a well-configured grace period aligned with typical TCB update intervals, the client will never skip the configured grace period for any TCB number update.
    #[prost(uint32, tag = "12")]
    pub tcb_evaluation_data_number_update_grace_period: u32,
    /// Next TCB evaluation data number scheduled to be updated
    ///
    /// Notes:
    /// - Must be zero if and only if `next_tcb_evaluation_data_number_update_time` is zero.
    /// - When `tcb_evaluation_data_number_update_grace_period` is zero, this field must always be zero.
    /// - If this is non-zero, this number must be always greater than the `current_tcb_evaluation_data_number`.
    #[prost(uint32, tag = "13")]
    pub next_tcb_evaluation_data_number: u32,
    /// Scheduled update time of the next TCB evaluation data number (UNIX time seconds)
    ///
    /// Notes:
    /// - Must be zero if and only if `next_tcb_evaluation_data_number` is zero.
    /// - When `tcb_evaluation_data_number_update_grace_period` is zero, this field must always be zero.
    #[prost(uint64, tag = "14")]
    pub next_tcb_evaluation_data_number_update_time: u64,
    /// Contains verifier-specific information for zkDCAP proofs.
    ///
    /// Data format:
    /// - First byte (0): zkVM type identifier.
    /// - Remaining bytes (1–N): zkVM-specific data.
    ///
    /// Currently, only RISC Zero zkVM (type=1) is supported, with the following format:
    ///
    /// | Byte(s) | Description                 |
    /// |---------|-----------------------------|
    /// | 0       | zkVM type (fixed as 1)      |
    /// | 1–31    | Reserved (set as zero)      |
    /// | 32–63   | Image ID                    |
    #[prost(bytes = "vec", repeated, tag = "15")]
    pub zkdcap_verifier_infos: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusState {
    /// An identifier that uniquely indicates the ELC state at a specific height
    ///
    /// Please check the state ID details: <<https://docs.lcp.network/protocol/elc#state-id>>
    #[prost(bytes = "vec", tag = "1")]
    pub state_id: ::prost::alloc::vec::Vec<u8>,
    /// The timestamp of the target chain's block corresponding to the consensus height,
    /// expressed in UNIX time (seconds).
    #[prost(uint64, tag = "2")]
    pub timestamp: u64,
}
